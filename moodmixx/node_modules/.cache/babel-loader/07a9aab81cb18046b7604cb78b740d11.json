{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nvar _framesync = require('framesync');\nvar _utils = require('../inc/utils');\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar Renderer = function () {\n  function Renderer(props) {\n    _classCallCheck(this, Renderer);\n    this.render = this.render.bind(this);\n    this.props = _extends({}, this.constructor.defaultProps, props);\n    this.state = {};\n    this.changedValues = [];\n  }\n\n  /**\n   * Get current state.\n   * If `key` is not defined, return entire cached state.\n   * If `key` is defined, return cached value if present.\n   * If `key` is defined and cached value is not present, read and return.\n   * @param  {string} (optional) key of value\n   * @return {value}\n   */\n\n  Renderer.prototype.get = function get(key) {\n    if (key) {\n      if (this.state[key] !== undefined) {\n        return this.state[key];\n      } else {\n        return this.read(key);\n      }\n    } else {\n      return this.state;\n    }\n  };\n\n  /**\n   * Read value according to `onRead`\n   * @param  {string} Name of property to read\n   * @return {[type]}\n   */\n\n  Renderer.prototype.read = function read(key) {\n    if (this.onRead) {\n      return this.onRead(key);\n    }\n  };\n\n  /**\n   * Update `state` with new values and schedule `render`.\n   * @param {object} values\n   * @param {value} value toset\n   */\n\n  Renderer.prototype.set = function set() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (typeof args[1] === 'undefined') {\n      var values = args[0];\n      // Set multiple values\n\n      for (var key in values) {\n        this.setValue(key, values[key]);\n      }\n    } else {\n      var _key2 = args[0],\n        value = args[1];\n      this.setValue(_key2, value);\n    }\n    if (this.hasChanged) {\n      (0, _framesync.onFrameRender)(this.render);\n    }\n    return this;\n  };\n\n  // > Wiley - 6 in the Morning\n  /**\n   * Set a single value\n   * If a string or number, set directly.\n   * If an object or array, create new object or array\n   * if it doesn't already exist. Then shallow compare\n   * to set and compare individual values.\n   * One of the clearer drawbacks and annoyances with\n   * using mutable instead of immutable states.\n   * @param {[type]} key\n   * @param {[type]} value\n   */\n\n  Renderer.prototype.setValue = function setValue(key, value) {\n    var currentValue = this.state[key];\n\n    // If number or string, set directly\n    if ((0, _utils.isNum)(value) || (0, _utils.isString)(value)) {\n      if (currentValue !== value) {\n        this.state[key] = value;\n        this.hasChanged = true;\n      }\n    } else if ((0, _utils.isArray)(value)) {\n      if (!currentValue) {\n        this.state[key] = [];\n      }\n      var numValues = value.length;\n      for (var i = 0; i < numValues; i++) {\n        if (this.state[key][i] !== value[i]) {\n          this.state[key][i] = value[i];\n          this.hasChanged = true;\n        }\n      }\n    } else if ((0, _utils.isObj)(value)) {\n      if (!currentValue) {\n        this.state[key] = {};\n      }\n      for (var valueKey in value) {\n        if (this.state[key][valueKey] !== value[valueKey]) {\n          this.state[key][valueKey] = value[valueKey];\n          this.hasChanged = true;\n        }\n      }\n    }\n    if (this.hasChanged && this.changedValues.indexOf(key) === -1) {\n      this.changedValues.push(key);\n    }\n  };\n\n  /**\n   * Fires `onRender` if values have changed or `forceRender`\n   * is set to true.\n   * @return {this}\n   */\n\n  Renderer.prototype.render = function render() {\n    var forceRender = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if ((forceRender || this.hasChanged) && this.onRender) {\n      this.onRender();\n    }\n    this.changedValues.length = 0;\n    this.hasChanged = false;\n    return this;\n  };\n  return Renderer;\n}();\nexports.default = Renderer;","map":{"version":3,"mappings":"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","names":["Renderer","props","_classCallCheck","render","bind","constructor","defaultProps","state","changedValues","get","key","undefined","read","onRead","set","args","values","setValue","value","hasChanged","currentValue","numValues","length","i","valueKey","indexOf","push","forceRender","onRender"],"sources":["/Users/gunhaar/Desktop/441proj/moodmixx/node_modules/popmotion/src/renderers/index.js"],"sourcesContent":["import { onFrameRender } from 'framesync';\nimport { isArray, isObj, isNum, isString } from '../inc/utils';\n\nclass Renderer {\n  constructor(props) {\n    this.render = this.render.bind(this);\n\n    this.props = {\n      ...this.constructor.defaultProps,\n      ...props\n    };\n\n    this.state = {};\n    this.changedValues = [];\n  }\n\n  /**\n   * Get current state.\n   * If `key` is not defined, return entire cached state.\n   * If `key` is defined, return cached value if present.\n   * If `key` is defined and cached value is not present, read and return.\n   * @param  {string} (optional) key of value\n   * @return {value}\n   */\n  get(key) {\n    if (key) {\n      if (this.state[key] !== undefined) {\n        return this.state[key];\n      } else {\n        return this.read(key);\n      }\n    } else {\n      return this.state;\n    }\n  }\n\n  /**\n   * Read value according to `onRead`\n   * @param  {string} Name of property to read\n   * @return {[type]}\n   */\n  read(key) {\n    if (this.onRead) {\n      return this.onRead(key);\n    }\n  }\n\n  /**\n   * Update `state` with new values and schedule `render`.\n   * @param {object} values\n   * @param {value} value toset\n   */\n  set(...args) {\n    if (typeof args[1] === 'undefined') {\n      const [ values ] = args;\n      // Set multiple values\n      for (const key in values) {\n        this.setValue(key, values[key]);\n      }\n    } else {\n      const [ key, value ] = args;\n      this.setValue(key, value);\n    }\n\n    if (this.hasChanged) {\n      onFrameRender(this.render);\n    }\n\n    return this;\n  }\n\n  // > Wiley - 6 in the Morning\n  /**\n   * Set a single value\n   * If a string or number, set directly.\n   * If an object or array, create new object or array\n   * if it doesn't already exist. Then shallow compare\n   * to set and compare individual values.\n   * One of the clearer drawbacks and annoyances with\n   * using mutable instead of immutable states.\n   * @param {[type]} key\n   * @param {[type]} value\n   */\n  setValue(key, value) {\n    const currentValue = this.state[key];\n\n    // If number or string, set directly\n    if (isNum(value) || isString(value)) {\n      if (currentValue !== value) {\n        this.state[key] = value;\n        this.hasChanged = true;\n      }\n    } else if (isArray(value)) {\n      if (!currentValue) {\n        this.state[key] = [];\n      }\n\n      const numValues = value.length;\n      for (let i = 0; i < numValues; i++) {\n        if (this.state[key][i] !== value[i]) {\n          this.state[key][i] = value[i];\n          this.hasChanged = true;\n        }\n      }\n    } else if (isObj(value)) {\n      if (!currentValue) {\n        this.state[key] = {};\n      }\n\n      for (let valueKey in value) {\n        if (this.state[key][valueKey] !== value[valueKey]) {\n          this.state[key][valueKey] = value[valueKey];\n          this.hasChanged = true;\n        }\n      }\n    }\n\n    if (this.hasChanged && this.changedValues.indexOf(key) === -1) {\n      this.changedValues.push(key);\n    }\n  }\n\n  /**\n   * Fires `onRender` if values have changed or `forceRender`\n   * is set to true.\n   * @return {this}\n   */\n  render(forceRender = false) {\n    if ((forceRender || this.hasChanged) && this.onRender) {\n      this.onRender();\n    }\n\n    this.changedValues.length = 0;\n    this.hasChanged = false;\n\n    return this;\n  }\n}\n\nexport default Renderer;\n"]},"metadata":{},"sourceType":"script"}