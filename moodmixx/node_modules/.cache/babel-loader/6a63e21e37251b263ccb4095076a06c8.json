{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.stepProgress = exports.speedPerSecond = exports.speedPerFrame = exports.smooth = exports.radiansToDegrees = exports.pointFromAngleAndDistance = exports.getValueFromProgress = exports.getProgressFromValue = exports.distance = exports.dilate = exports.degreesToRadians = exports.angle = undefined;\nvar _utils = require('./utils');\n\n/*\n  Convert number to x decimal places\n\n  @param [number]\n  @param [number]\n  @return [number]\n*/\nvar toDecimal = function toDecimal(num) {\n  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n  precision = Math.pow(10, precision);\n  return Math.round(num * precision) / precision;\n};\nvar ZERO_POINT = {\n  x: 0,\n  y: 0,\n  z: 0\n};\nvar distance1D = function distance1D(a, b) {\n  return Math.abs(a - b);\n};\n\n/*\n  Angle between points\n\n  Translates the hypothetical line so that the 'from' coordinates\n  are at 0,0\n\n  @param [object]: X and Y coordinates of from point\n  @param [object]: X and Y cordinates of to point\n  @return [radian]: Angle between the two points in radians\n*/\nvar angle = exports.angle = function angle(a) {\n  var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ZERO_POINT;\n  return radiansToDegrees(Math.atan2(b.y - a.y, b.x - a.x));\n};\n\n/*\n  Convert degrees to radians\n\n  @param [number]: Value in degrees\n  @return [number]: Value in radians\n*/\nvar degreesToRadians = exports.degreesToRadians = function degreesToRadians(degrees) {\n  return degrees * Math.PI / 180;\n};\n\n/*\n  Dilate\n\n  Change the progression between a and b according to dilation.\n\n  So dilation = 0.5 would change\n\n  a --------- b\n\n  to\n\n  a ---- b\n\n  @param [number]: Previous value\n  @param [number]: Current value\n  @param [number]: Dilate progress by x\n  @return [number]: Previous value plus the dilated difference\n*/\nvar dilate = exports.dilate = function dilate(a, b, dilation) {\n  return a + (b - a) * dilation;\n};\n\n/*\n  Distance\n\n  Returns the distance between two n dimensional points.\n\n  @param [object/number]: x and y or just x of point A\n  @param [object/number]: (optional): x and y or just x of point B\n  @return [number]: The distance between the two points\n*/\nvar distance = exports.distance = function distance(a) {\n  var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ZERO_POINT;\n\n  // 1D dimensions\n  if ((0, _utils.isNum)(a)) {\n    return distance1D(a, b);\n\n    // Multi-dimensional\n  } else {\n    var xDelta = distance1D(a.x, b.x);\n    var yDelta = distance1D(a.y, b.y);\n    var zDelta = (0, _utils.isNum)(a.z) ? distance1D(a.z, b.z) : 0;\n    return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));\n  }\n};\n\n/*\n  Progress within given range\n\n  Given a lower limit and an upper limit, we return the progress\n  (expressed as a number 0-1) represented by the given value, and\n  limit that progress to within 0-1.\n\n  @param [number]: Lower limit\n  @param [number]: Upper limit\n  @param [number]: Value to find progress within given range\n  @return [number]: Progress of value within range as expressed 0-1\n*/\nvar getProgressFromValue = exports.getProgressFromValue = function getProgressFromValue(from, to, value) {\n  return (value - from) / (to - from);\n};\n\n/*\n  Value in range from progress\n\n  Given a lower limit and an upper limit, we return the value within\n  that range as expressed by progress (a number from 0-1)\n\n  @param [number]: Lower limit of range\n  @param [number]: Upper limit of range\n  @param [number]: The progress between lower and upper limits expressed 0-1\n  @return [number]: Value as calculated from progress within range (not limited within range)\n*/\nvar getValueFromProgress = exports.getValueFromProgress = function getValueFromProgress(from, to, progress) {\n  return -progress * from + progress * to + from;\n};\n\n/*\n  Point from angle and distance\n\n  @param [object]: 2D point of origin\n  @param [number]: Angle from origin\n  @param [number]: Distance from origin\n  @return [object]: Calculated 2D point\n*/\nvar pointFromAngleAndDistance = exports.pointFromAngleAndDistance = function pointFromAngleAndDistance(origin, angle, distance) {\n  angle = degreesToRadians(angle);\n  return {\n    x: distance * Math.cos(angle) + origin.x,\n    y: distance * Math.sin(angle) + origin.y\n  };\n};\n\n/*\n  Convert radians to degrees\n\n  @param [number]: Value in radians\n  @return [number]: Value in degrees\n*/\nvar radiansToDegrees = exports.radiansToDegrees = function radiansToDegrees(radians) {\n  return radians * 180 / Math.PI;\n};\n\n/*\n  Framerate-independent smoothing\n\n  @param [number]: New value\n  @param [number]: Old value\n  @param [number]: Frame duration\n  @param [number] (optional): Smoothing (0 is none)\n*/\nvar smooth = exports.smooth = function smooth(newValue, oldValue, duration) {\n  var smoothing = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  return toDecimal(oldValue + duration * (newValue - oldValue) / Math.max(smoothing, duration));\n};\n\n/*\n  Convert x per second to per frame velocity based on fps\n\n  @param [number]: Unit per second\n  @param [number]: Frame duration in ms\n*/\nvar speedPerFrame = exports.speedPerFrame = function speedPerFrame(xps, frameDuration) {\n  return (0, _utils.isNum)(xps) ? xps / (1000 / frameDuration) : 0;\n};\n\n/*\n  Convert velocity into velicity per second\n\n  @param [number]: Unit per frame\n  @param [number]: Frame duration in ms\n*/\nvar speedPerSecond = exports.speedPerSecond = function speedPerSecond(velocity, frameDuration) {\n  return frameDuration ? velocity * (1000 / frameDuration) : 0;\n};\n\n/*\n  Create stepped version of 0-1 progress\n\n  @param [int]: Number of steps\n  @param [number]: Current value\n  @return [number]: Stepped value\n*/\nvar stepProgress = exports.stepProgress = function stepProgress(steps, progress) {\n  var segment = 1 / (steps - 1);\n  var target = 1 - 1 / steps;\n  var progressOfTarget = Math.min(progress / target, 1);\n  return Math.floor(progressOfTarget / segment) * segment;\n};","map":{"version":3,"mappings":"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","names":["toDecimal","num","precision","Math","round","ZERO_POINT","x","y","z","distance1D","a","b","abs","angle","radiansToDegrees","atan2","degreesToRadians","degrees","PI","dilate","dilation","distance","xDelta","yDelta","zDelta","sqrt","getProgressFromValue","from","to","value","getValueFromProgress","progress","pointFromAngleAndDistance","origin","cos","sin","radians","smooth","newValue","oldValue","duration","smoothing","max","speedPerFrame","xps","frameDuration","speedPerSecond","velocity","stepProgress","steps","segment","target","progressOfTarget","min","floor"],"sources":["/Users/gunhaar/Desktop/441proj/moodmixx/node_modules/popmotion/src/inc/calc.js"],"sourcesContent":["import { isNum } from './utils';\n\n/*\n  Convert number to x decimal places\n\n  @param [number]\n  @param [number]\n  @return [number]\n*/\nconst toDecimal = (num, precision = 2) => {\n  precision = 10 ** precision;\n  return Math.round(num * precision) / precision;\n};\n\nconst ZERO_POINT = {\n  x: 0,\n  y: 0,\n  z: 0\n};\n\nconst distance1D = (a, b) => Math.abs(a - b);\n\n/*\n  Angle between points\n\n  Translates the hypothetical line so that the 'from' coordinates\n  are at 0,0\n\n  @param [object]: X and Y coordinates of from point\n  @param [object]: X and Y cordinates of to point\n  @return [radian]: Angle between the two points in radians\n*/\nexport const angle = (a, b = ZERO_POINT) => radiansToDegrees(Math.atan2(b.y - a.y, b.x - a.x));\n\n/*\n  Convert degrees to radians\n\n  @param [number]: Value in degrees\n  @return [number]: Value in radians\n*/\nexport const degreesToRadians = (degrees) => degrees * Math.PI / 180;\n\n/*\n  Dilate\n\n  Change the progression between a and b according to dilation.\n\n  So dilation = 0.5 would change\n\n  a --------- b\n\n  to\n\n  a ---- b\n\n  @param [number]: Previous value\n  @param [number]: Current value\n  @param [number]: Dilate progress by x\n  @return [number]: Previous value plus the dilated difference\n*/\nexport const dilate = (a, b, dilation) => a + ((b - a) * dilation);\n\n/*\n  Distance\n\n  Returns the distance between two n dimensional points.\n\n  @param [object/number]: x and y or just x of point A\n  @param [object/number]: (optional): x and y or just x of point B\n  @return [number]: The distance between the two points\n*/\nexport const distance = (a, b = ZERO_POINT) => {\n  // 1D dimensions\n  if (isNum(a)) {\n    return distance1D(a, b);\n\n  // Multi-dimensional\n  } else {\n    const xDelta = distance1D(a.x, b.x);\n    const yDelta = distance1D(a.y, b.y);\n    const zDelta = (isNum(a.z)) ? distance1D(a.z, b.z) : 0;\n\n    return Math.sqrt((xDelta ** 2) + (yDelta ** 2) + (zDelta ** 2));\n  }\n};\n\n/*\n  Progress within given range\n\n  Given a lower limit and an upper limit, we return the progress\n  (expressed as a number 0-1) represented by the given value, and\n  limit that progress to within 0-1.\n\n  @param [number]: Lower limit\n  @param [number]: Upper limit\n  @param [number]: Value to find progress within given range\n  @return [number]: Progress of value within range as expressed 0-1\n*/\nexport const getProgressFromValue = (from, to, value) => (value - from) / (to - from);\n\n/*\n  Value in range from progress\n\n  Given a lower limit and an upper limit, we return the value within\n  that range as expressed by progress (a number from 0-1)\n\n  @param [number]: Lower limit of range\n  @param [number]: Upper limit of range\n  @param [number]: The progress between lower and upper limits expressed 0-1\n  @return [number]: Value as calculated from progress within range (not limited within range)\n*/\nexport const getValueFromProgress = (from, to, progress) => (- progress * from) + (progress * to) + from;\n\n/*\n  Point from angle and distance\n\n  @param [object]: 2D point of origin\n  @param [number]: Angle from origin\n  @param [number]: Distance from origin\n  @return [object]: Calculated 2D point\n*/\nexport const pointFromAngleAndDistance = (origin, angle, distance) => {\n  angle = degreesToRadians(angle);\n\n  return {\n    x: distance * Math.cos(angle) + origin.x,\n    y: distance * Math.sin(angle) + origin.y\n  };\n};\n\n/*\n  Convert radians to degrees\n\n  @param [number]: Value in radians\n  @return [number]: Value in degrees\n*/\nexport const radiansToDegrees = (radians) => radians * 180 / Math.PI;\n\n/*\n  Framerate-independent smoothing\n\n  @param [number]: New value\n  @param [number]: Old value\n  @param [number]: Frame duration\n  @param [number] (optional): Smoothing (0 is none)\n*/\nexport const smooth = (newValue, oldValue, duration, smoothing = 0) => toDecimal(oldValue + (duration * (newValue - oldValue) / Math.max(smoothing, duration)));\n\n/*\n  Convert x per second to per frame velocity based on fps\n\n  @param [number]: Unit per second\n  @param [number]: Frame duration in ms\n*/\nexport const speedPerFrame = (xps, frameDuration) => (isNum(xps)) ? xps / (1000 / frameDuration) : 0;\n\n/*\n  Convert velocity into velicity per second\n\n  @param [number]: Unit per frame\n  @param [number]: Frame duration in ms\n*/\nexport const speedPerSecond = (velocity, frameDuration) => frameDuration ? velocity * (1000 / frameDuration) : 0;\n\n/*\n  Create stepped version of 0-1 progress\n\n  @param [int]: Number of steps\n  @param [number]: Current value\n  @return [number]: Stepped value\n*/\nexport const stepProgress = (steps, progress) => {\n  const segment = 1 / (steps - 1);\n  const target = 1 - (1 / steps);\n  const progressOfTarget = Math.min(progress / target, 1);\n\n  return Math.floor(progressOfTarget / segment) * segment;\n};\n"]},"metadata":{},"sourceType":"script"}