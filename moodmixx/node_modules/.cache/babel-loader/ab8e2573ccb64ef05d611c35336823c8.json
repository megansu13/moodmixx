{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.complex = exports.color = exports.hsla = exports.hex = exports.rgba = exports.rgbUnit = exports.scale = exports.px = exports.percent = exports.degrees = exports.alpha = exports.number = undefined;\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n}; /**\n    * Value types\n    *\n    * alpha\n    * degrees\n    * hex\n    * hsla\n    * percent\n    * px\n    * rgbUnit\n    * rgb\n    * scale\n    */\n\nvar _transformers = require('./transformers');\nvar _parsers = require('./parsers');\nvar _utils = require('./utils');\nvar number = exports.number = {\n  test: _utils.isNum,\n  parse: parseFloat\n};\n\n// Value types\nvar alpha = exports.alpha = _extends({}, number, {\n  transform: _transformers.alpha\n});\nvar degrees = exports.degrees = (0, _utils.createUnitType)('deg', _transformers.degrees);\nvar percent = exports.percent = (0, _utils.createUnitType)('%', _transformers.percent);\nvar px = exports.px = (0, _utils.createUnitType)('px', _transformers.px);\nvar scale = exports.scale = _extends({}, number, {\n  default: 1\n});\nvar rgbUnit = exports.rgbUnit = _extends({}, number, {\n  transform: _transformers.rgbUnit\n});\nvar rgba = exports.rgba = {\n  test: _utils.isRgb,\n  parse: _parsers.rgba,\n  transform: _transformers.rgba\n};\nvar hex = exports.hex = _extends({}, rgba, {\n  test: _utils.isHex,\n  parse: _parsers.hex\n});\nvar hsla = exports.hsla = {\n  test: _utils.isHsl,\n  parse: _parsers.hsla,\n  transform: _transformers.hsla\n};\nvar color = exports.color = {\n  parse: _parsers.color,\n  test: _utils.isColor,\n  transform: _transformers.color\n};\nvar FLOAT_REGEX = /(-)?(\\d[\\d\\.]*)/g;\nvar generateToken = function generateToken(token) {\n  return '${' + token + '}';\n};\nvar complex = exports.complex = {\n  test: function test(v) {\n    var matches = v.match && v.match(FLOAT_REGEX);\n    return (0, _utils.isArray)(matches) && matches.length > 1;\n  },\n  parse: function parse(v) {\n    var parsedValue = {};\n    v.match(FLOAT_REGEX).forEach(function (value, i) {\n      return parsedValue[i] = parseFloat(value);\n    });\n    return parsedValue;\n  },\n  createTransformer: function createTransformer(prop) {\n    var counter = 0;\n    var template = prop.replace(FLOAT_REGEX, function () {\n      return generateToken(counter++);\n    });\n    return function (v) {\n      var output = template;\n      for (var key in v) {\n        if (v.hasOwnProperty(key)) {\n          output = output.replace(generateToken(key), v[key]);\n        }\n      }\n      return output;\n    };\n  }\n};","map":{"version":3,"mappings":";;;;;;;;;;;;;;GAAA;;;;;;;;;;;;;;AAaA;AAUA;AAMA;AAUO,IAAMA,0BAAS;EACpBC,kBADoB;EAEpBC,OAAOC;AAFa,CAAf;;AAKP;AACO,IAAMC,qCACRJ,MADQ;EAEXK;AAFW,EAAN;AAKA,IAAMC,4BAAU,2BAAe,KAAf,wBAAhB;AACA,IAAMC,4BAAU,2BAAe,GAAf,wBAAhB;AACA,IAAMC,kBAAK,2BAAe,IAAf,mBAAX;AAEA,IAAMC,qCACRT,MADQ;EAEXU,SAAS;AAFE,EAAN;AAKA,IAAMC,yCACRX,MADQ;EAEXK;AAFW,EAAN;AAKA,IAAMO,sBAAO;EAClBX,kBADkB;EAElBC,oBAFkB;EAGlBG;AAHkB,CAAb;AAMA,IAAMQ,iCACRD,IADQ;EAEXX,kBAFW;EAGXC;AAHW,EAAN;AAMA,IAAMY,sBAAO;EAClBb,kBADkB;EAElBC,oBAFkB;EAGlBG;AAHkB,CAAb;AAMA,IAAMU,wBAAQ;EACnBb,qBADmB;EAEnBD,oBAFmB;EAGnBI;AAHmB,CAAd;AAMP,IAAMW,cAAc,kBAApB;AACA,IAAMC,gBAAgB,SAAhBA,aAAgB,CAACC,KAAD;EAAA,OAAW,OAAOA,KAAP,GAAe,GAA1B;AAAA,CAAtB;AACO,IAAMC,4BAAU;EACrBlB,MAAM,cAACmB,CAAD,EAAO;IACX,IAAMC,UAAUD,EAAEE,KAAF,IAAWF,EAAEE,KAAF,CAAQN,WAAR,CAA3B;IACA,OAAQ,oBAAQK,OAAR,KAAoBA,QAAQE,MAAR,GAAiB,CAA7C;EACD,CAJoB;EAKrBrB,OAAO,eAACkB,CAAD,EAAO;IACZ,IAAMI,cAAc,EAApB;IACAJ,EAAEE,KAAF,CAAQN,WAAR,EAAqBS,OAArB,CAA6B,UAACC,KAAD,EAAQC,CAAR;MAAA,OAAcH,YAAYG,CAAZ,IAAiBxB,WAAWuB,KAAX,CAA/B;IAAA,CAA7B;IACA,OAAOF,WAAP;EACD,CAToB;EAUrBI,mBAAmB,2BAACC,IAAD,EAAU;IAC3B,IAAIC,UAAU,CAAd;IACA,IAAMC,WAAWF,KAAKG,OAAL,CAAahB,WAAb,EAA0B;MAAA,OAAMC,cAAca,SAAd,CAAN;IAAA,CAA1B,CAAjB;IAEA,OAAO,UAACV,CAAD,EAAO;MACZ,IAAIa,SAASF,QAAb;MACA,KAAK,IAAIG,GAAT,IAAgBd,CAAhB,EAAmB;QACjB,IAAIA,EAAEe,cAAF,CAAiBD,GAAjB,CAAJ,EAA2B;UACzBD,SAASA,OAAOD,OAAP,CAAef,cAAciB,GAAd,CAAf,EAAmCd,EAAEc,GAAF,CAAnC,CAAT;QACD;MACF;MAED,OAAOD,MAAP;IACD,CATD;EAUD;AAxBoB,CAAhB","names":["number","test","parse","parseFloat","alpha","transform","degrees","percent","px","scale","default","rgbUnit","rgba","hex","hsla","color","FLOAT_REGEX","generateToken","token","complex","v","matches","match","length","parsedValue","forEach","value","i","createTransformer","prop","counter","template","replace","output","key","hasOwnProperty"],"sources":["/Users/megansu/Desktop/eecs441/moodmixx/moodmixx/node_modules/popmotion/src/inc/value-types.js"],"sourcesContent":["/**\n * Value types\n *\n * alpha\n * degrees\n * hex\n * hsla\n * percent\n * px\n * rgbUnit\n * rgb\n * scale\n */\nimport {\n  rgbUnit as transformRGBUnit,\n  rgba as transformRgba,\n  alpha as transformAlpha,\n  hsla as transformHsla,\n  color as transformColor,\n  px as transformPx,\n  percent as transformPercent,\n  degrees as transformDegrees\n} from './transformers';\nimport {\n  hex as parseHex,\n  rgba as parseRgba,\n  hsla as parseHsla,\n  color as parseColor\n} from './parsers';\nimport {\n  createUnitType,\n  isArray,\n  isNum,\n  isRgb,\n  isHsl,\n  isHex,\n  isColor\n} from './utils';\n\nexport const number = {\n  test: isNum,\n  parse: parseFloat\n};\n\n// Value types\nexport const alpha = {\n  ...number,\n  transform: transformAlpha\n};\n\nexport const degrees = createUnitType('deg', transformDegrees);\nexport const percent = createUnitType('%', transformPercent);\nexport const px = createUnitType('px', transformPx);\n\nexport const scale = {\n  ...number,\n  default: 1\n};\n\nexport const rgbUnit = {\n  ...number,\n  transform: transformRGBUnit\n};\n\nexport const rgba = {\n  test: isRgb,\n  parse: parseRgba,\n  transform: transformRgba\n};\n\nexport const hex = {\n  ...rgba,\n  test: isHex,\n  parse: parseHex\n};\n\nexport const hsla = {\n  test: isHsl,\n  parse: parseHsla,\n  transform: transformHsla\n};\n\nexport const color = {\n  parse: parseColor,\n  test: isColor,\n  transform: transformColor\n};\n\nconst FLOAT_REGEX = /(-)?(\\d[\\d\\.]*)/g;\nconst generateToken = (token) => '${' + token + '}';\nexport const complex = {\n  test: (v) => {\n    const matches = v.match && v.match(FLOAT_REGEX);\n    return (isArray(matches) && matches.length > 1);\n  },\n  parse: (v) => {\n    const parsedValue = {};\n    v.match(FLOAT_REGEX).forEach((value, i) => parsedValue[i] = parseFloat(value));\n    return parsedValue;\n  },\n  createTransformer: (prop) => {\n    let counter = 0;\n    const template = prop.replace(FLOAT_REGEX, () => generateToken(counter++));\n\n    return (v) => {\n      let output = template;\n      for (let key in v) {\n        if (v.hasOwnProperty(key)) {\n          output = output.replace(generateToken(key), v[key]);\n        }\n      }\n\n      return output;\n    };\n  }\n};\n"]},"metadata":{},"sourceType":"script"}